# Supabase Auth + Next.js 프로젝트 규칙

## 프로젝트 개요
- **Framework**: Next.js 16 (App Router)
- **Language**: TypeScript (strict mode)
- **Styling**: Tailwind CSS v4
- **UI Library**: shadcn/ui (new-york style, zinc base color)
- **Auth**: Supabase Auth (Google, GitHub, Email OTP, Email/Password)
- **Database**: Supabase PostgreSQL with RLS (Row Level Security)
- **Package Manager**: npm

## 프로젝트 구조

```
src/
  app/                    # Next.js App Router
    (auth)/              # Route group
      signin/            # 로그인 페이지
    admin/               # 관리자 페이지
    api/                 # API Routes
      auth/signout/      # 로그아웃 (Route Handler)
      profile/ensure/    # 프로필 확인/생성
      session/           # JWT 쿠키 저장
      supabase-session/  # Supabase 세션 쿠키 저장
    auth/                # 인증 관련
      callback/          # OAuth 콜백 (클라이언트 컴포넌트)
      verify/            # 이메일 인증 안내
      update-password/  # 비밀번호 변경
    dashboard/           # 보호된 페이지
    profiles/            # 프로필 목록 (검색/페이징)
    notes/               # RLS 예제
  components/
    ui/                  # shadcn/ui 컴포넌트
    profiles/            # 프로필 관련 컴포넌트
  lib/
    supabase/
      client.ts         # 브라우저 Supabase 클라이언트 (싱글턴)
      server.ts         # 서버 Supabase 클라이언트 (읽기 전용)
    logger.ts           # 인증 로그 유틸
    utils.ts            # shadcn/ui utils
middleware.ts           # 세션 쿠키 동기화
supabase/               # SQL 스크립트
  profiles.sql          # 프로필 테이블/트리거
  notes.sql             # 노트 테이블/RLS
  admin-policies.sql    # 관리자 RLS 정책
  migrate-existing-profiles.sql  # 기존 데이터 마이그레이션
```

## 인증 및 세션 관리

### 브라우저 클라이언트 (`src/lib/supabase/client.ts`)
- 싱글턴 패턴 사용 (`getBrowserSupabase()`)
- PKCE flow (`flowType: "pkce"`)
- `detectSessionInUrl: true` (자동 세션 교환)
- localStorage 키: `"app-auth"`

### 서버 클라이언트 (`src/lib/supabase/server.ts`)
- **중요**: Next.js 15 제약으로 서버 컴포넌트에서는 쿠키 읽기만 가능
- `set()`, `remove()`는 no-op (미들웨어에서 처리)
- 쿠키 수정이 필요하면 Route Handler에서 별도 클라이언트 생성

### 미들웨어 (`middleware.ts`)
- 모든 요청에서 Supabase 세션 쿠키 동기화
- `supabase.auth.getSession()` 호출로 쿠키 자동 업데이트

### 세션 이중 관리
1. **브라우저**: localStorage에 저장 (PKCE code_verifier 포함)
2. **서버**: HttpOnly 쿠키
   - Supabase 세션 쿠키 (자동 관리)
   - `app_jwt` 쿠키 (access_token 저장, 커스텀 API 인증용)

### OAuth 플로우
1. `/signin` → `signInWithOAuth()` → Provider 리다이렉트
2. Provider 인증 완료 → `/auth/callback?code=...`
3. 콜백 페이지: `detectSessionInUrl=true`로 자동 교환
4. `/api/session`에 access_token 전달 → `app_jwt` 쿠키 저장
5. `/api/supabase-session`에 access_token/refresh_token 전달 → 서버 쿠키 설정
6. `/api/profile/ensure`로 프로필 확인/생성 (signup/signin 구분)
7. `/dashboard`로 리다이렉트

## 데이터베이스 스키마

### `public.profiles` 테이블
- **Primary Key**: `id` (uuid, references `auth.users.id`)
- **컬럼**: email, full_name, name, avatar_url, provider, bio, website, gender, phone_number, created_at, updated_at
- **RLS**: 본인 프로필만 조회/수정 가능
- **트리거**: `auth.users` INSERT 시 자동으로 `profiles`에도 INSERT

### `public.notes` 테이블
- **컬럼**: id, user_id, content, created_at
- **RLS**: 본인 노트만 CRUD 가능

## 코딩 규칙

### 파일 네이밍
- 컴포넌트: PascalCase (예: `ProfilesList.tsx`)
- 유틸/라이브러리: camelCase (예: `getServerSupabase()`)
- Route Handler: `route.ts`
- 페이지: `page.tsx`

### Import 경로
- 절대 경로 사용: `@/components/ui/button`
- `tsconfig.json`의 `paths` 설정 활용

### 컴포넌트 분리
- UI 컴포넌트는 `src/components/` 디렉토리
- 재사용 가능한 컴포넌트는 분리
- shadcn/ui 컴포넌트는 `src/components/ui/`

### 서버/클라이언트 구분
- 서버 컴포넌트 기본 (async 가능)
- `"use client"`는 상태/이벤트 핸들러 필요 시만
- 서버 액션: `"use server"` 지시어 사용

### 에러 처리
- try-catch 사용
- `logAuth()`로 인증 관련 로그 기록
- 사용자에게는 간단한 메시지, 로그에는 상세 정보

### 타입 안전성
- `unknown` 타입 사용 후 타입 가드로 검증
- `err instanceof Error`로 에러 타입 확인
- Supabase 타입 활용

### 쿠키 제약 사항
- **서버 컴포넌트**: 읽기 전용 (`cookies().get()`)
- **Route Handler**: 읽기/쓰기 가능 (`NextResponse.cookies.set()`)
- **Server Action**: 읽기 전용 또는 Route Handler 호출

### 검색 및 페이징
- Supabase의 `.or()` 및 `.ilike()` 사용
- `.range(offset, offset + pageSize - 1)`로 페이징
- `count: "exact"`로 총 개수 조회

## 환경 변수

```bash
NEXT_PUBLIC_SUPABASE_URL="https://YOUR-PROJECT-REF.supabase.co"
NEXT_PUBLIC_SUPABASE_ANON_KEY="YOUR-ANON-KEY"
NEXT_PUBLIC_SITE_URL="http://localhost:3000"  # 개발: localhost, 배포: 실제 도메인
```

## 인증 로그

- `logAuth()` 함수로 인증 플로우 로깅
- 개발 환경에서는 항상 활성화
- 프로덕션에서는 `NEXT_PUBLIC_DEBUG_AUTH=1` 또는 `DEBUG_AUTH=1`로 제어

## 보안 고려사항

1. **RLS 정책**: 모든 테이블에 Row Level Security 활성화
2. **JWT 쿠키**: HttpOnly, Secure (프로덕션), SameSite=lax
3. **세션 관리**: 미들웨어에서 자동 동기화
4. **쿠키 수정**: 서버 컴포넌트에서는 불가, Route Handler에서만 가능

## 일반 규칙

1. **한국어 주석/메시지**: 사용자 대상 텍스트는 한국어
2. **코드 주석**: 복잡한 로직에만 간단히
3. **에러 메시지**: 사용자 친화적, 로그에는 상세 정보
4. **컴포넌트 분리**: 재사용성과 유지보수성 고려
5. **타입 안전성**: TypeScript strict mode 준수
6. **일관성**: 기존 패턴과 스타일 유지
7. **Description 필드**: 모든 주요 엔티티에 `description` 필드 포함 (Policy, State, Role, Group, Type, Attribute, Type, BusinessObject)

## API 엔드포인트

- `POST /api/session`: access_token을 `app_jwt` 쿠키로 저장
- `POST /api/supabase-session`: access_token/refresh_token으로 서버 쿠키 설정
- `POST /api/profile/ensure`: 프로필 확인/생성 (트리거 실패 시 백업)
- `POST /api/auth/signout`: 로그아웃 (Route Handler)

## SQL 실행 순서

1. `supabase/profiles.sql`: 테이블 생성, RLS 정책, 트리거
2. `supabase/migrate-existing-profiles.sql`: 기존 사용자 프로필 생성 (필요 시)
3. `supabase/notes.sql`: 노트 테이블 및 RLS (예제)
4. `supabase/admin-policies.sql`: 관리자 RLS 정책 (선택)

## Policy 기반 권한 관리 시스템

### 데이터 모델 (Prisma)

- **ORM**: Prisma Client
- **데이터베이스**: PostgreSQL (Supabase)
- **주요 테이블**:
  - `Policy`: 권한 정책 (`types: string[]`)
  - `State`: Policy 내 상태 (다중 next state 지원)
  - `StateTransition`: State 간 전이 관계
  - `Permission`: State별 권한 (User/Role/Group × create/view/modify/delete)
  - `Role`, `Group`: 역할 및 그룹 정의
  - `UserRole`, `UserGroup`: User와의 Many-to-Many 관계

### State 전이 관리

- `StateTransition` 테이블로 다중 next state 지원
- `condition` 필드로 전이 조건 (expression) 저장
- `order` 필드로 State 순서 관리 (State Diagram 표시용)

### 권한 평가

- **직접 권한**: `UserPermission` (User별)
- **Role 권한**: `Permission` (targetType='role')
- **Group 권한**: `Permission` (targetType='group')
- **Expression 평가**: `expression` 필드 평가 결과가 `true`일 때만 적용
- 평가기: `src/lib/policy/evaluator.ts`의 `evaluateExpression()`
- **멀티 Action**: `action` 필드는 쉼표로 구분된 여러 action 포함 가능 (예: "create,modify,delete")
  - `checkActionMatch()` 함수로 요청된 action이 포함되어 있는지 확인

### UI 관리

- **상태 다이어그램**: State 간 전이 관계 시각화
- **권한 테이블**: Resource × Action × Target (User/Role/Group) 조합 관리
- 각 행별로 Role, Group, User 권한 추가 가능
- Expression 편집기로 조건 입력
- **Action 멀티 선택**: Permission 생성/수정 시 Checkbox로 여러 action 선택 가능
  - 저장 시 쉼표로 join하여 저장
  - 조회 시 split하여 여러 개의 Badge로 표시

### 필터링 및 페이징 (Permission, StateTransition 페이지)

- **Policy 검색**: 2자 이상 입력 시 드롭다운으로 검색 결과 표시
- **클라이언트 사이드 필터링**: 모든 데이터를 먼저 로드하고 클라이언트에서 필터링
- **클라이언트 사이드 페이징**: 필터링된 데이터 기준으로 클라이언트에서 페이징 처리
- **페이지 크기 선택**: 10, 20, 50, 100, 전체 중 선택 가능
- 필터 변경 시 자동으로 첫 페이지로 이동

### 파일 위치

- `prisma/schema.prisma`: Prisma 스키마 정의
- `src/lib/policy/types.ts`: TypeScript 타입 정의
- `src/lib/policy/evaluator.ts`: Expression 평가기
- `src/lib/business-type-utils.ts`: Type 유틸리티 함수 (속성 상속)
- `src/lib/prisma/middleware.ts`: 리비전 자동 할당 미들웨어

### Expression 평가 보안

- 현재는 `new Function()` 사용 (개발용)
- 프로덕션에서는 Sandbox 환경 또는 AST 파서 사용 권장
- 사용자 입력 expression은 반드시 검증 필요

## 테이블 UI 구현 패턴

### 기본 구조

**모든 관리 페이지의 테이블은 다음 구조를 따릅니다:**

#### 1. 페이지 컴포넌트 (`page.tsx`)

```tsx
const DEFAULT_PAGE_SIZE = 20

type Props = {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>
}

export default async function SomePage({ searchParams }: Props) {
  const params = await searchParams
  const page = typeof params.page === 'string' ? parseInt(params.page, 10) : 1
  const pageSizeParam = typeof params.pageSize === 'string' ? params.pageSize : String(DEFAULT_PAGE_SIZE)
  const pageSize = pageSizeParam === 'all' ? 999999 : parseInt(pageSizeParam, 10)
  
  const { data, total } = await getData(page, pageSize)
  const totalPages = Math.ceil(total / pageSize)

  return (
    <div className="admin-page-container">
      <div className="admin-list-wrapper">
        <Suspense fallback={<div>로딩 중...</div>}>
          <SomeList initialData={data} />
        </Suspense>
      </div>

      <div className="admin-table-spacing">
        <Pagination
          currentPage={page}
          totalPages={totalPages}
          totalCount={total}
          pageSize={pageSize}
          baseUrl="/admin/some"
        />
      </div>
    </div>
  )
}
```

#### 2. List 컴포넌트 (`List.tsx`)

```tsx
'use client'

import { Card, CardContent } from '@/components/ui/card'
import { ScrollableTable } from '@/components/ui/scrollable-table'

export function SomeList({ initialData }: { initialData: Data[] }) {
  return (
    <div className="flex flex-col h-full mt-2.5">
      {/* 헤더 카드: 타이틀 + 설명 + 버튼 (필터 포함 가능) */}
      <div className="admin-header-wrapper">
        <Card>
          {/* 필터가 없는 경우 */}
          <CardContent className="admin-header-card-content">
            <h1 className="text-lg font-bold tracking-tight">제목</h1>
            <p className="text-sm text-muted-foreground">설명</p>
            <div className="flex-1" />
            <Button onClick={handleCreate}>
              <PlusCircle className="mr-2 h-4 w-4" />
              새 항목 생성
            </Button>
          </CardContent>

          {/* 필터가 있는 경우 (Permission, Transition 등) */}
          <CardContent className="admin-header-card-content flex-col items-start">
            {/* 타이틀 행 */}
            <div className="flex items-center w-full gap-2">
              <h1 className="text-lg font-bold tracking-tight">제목</h1>
              <p className="text-sm text-muted-foreground">설명</p>
              <div className="flex-1" />
              <Button onClick={handleCreate}>
                <PlusCircle className="mr-2 h-4 w-4" />
                새 항목 생성
              </Button>
            </div>
            
            {/* 필터 행 */}
            <div className="flex gap-2 items-center w-full mt-2">
              <Input placeholder="검색..." />
            </div>
          </CardContent>
        </Card>
      </div>

      <ScrollableTable>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>컬럼1</TableHead>
              <TableHead className="w-20">컬럼2</TableHead>
              {/* ... */}
            </TableRow>
          </TableHeader>
          <TableBody>
            {initialData.map((item) => (
              <TableRow key={item.id}>
                <TableCell>{item.name}</TableCell>
                {/* ... */}
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </ScrollableTable>
    </div>
  )
}
```

#### 3. CSS 스타일 (`globals.css`)

```css
@layer components {
  /* 테이블 행 높이 */
  table tbody tr {
    @apply h-12;  /* 48px */
  }
  
  table thead tr {
    @apply h-12;
  }
  
  table tbody td,
  table thead th {
    @apply py-2 px-4;
  }
  
  /* 스크롤 가능한 테이블 컨테이너 */
  .scrollable-table-container {
    display: flex;
    flex-direction: column;
    flex: 1;
    min-height: 0;
    border: 1px solid hsl(var(--border));
    border-radius: 0.5rem;
    overflow: hidden;
  }
  
  /* 헤더 영역 (고정, 스크롤바 숨김) */
  .table-header-wrapper {
    flex-shrink: 0;
    overflow-x: auto;
    overflow-y: hidden;
    scrollbar-width: none;  /* Firefox */
    -ms-overflow-style: none;  /* IE/Edge */
    padding-right: 10px;  /* 바디 스크롤바 너비만큼 패딩 추가 */
  }
  
  .table-header-wrapper::-webkit-scrollbar {
    display: none;  /* Chrome/Safari/Opera */
  }
  
  .table-header-wrapper table {
    width: fit-content;
    min-width: 100%;
    table-layout: auto;
  }
  
  /* 바디 영역 (가로/세로 스크롤) */
  .scrollable-table-wrapper {
    overflow-x: auto;
    overflow-y: auto;
    flex: 1;
  }
  
  .scrollable-table-wrapper table {
    width: fit-content;
    min-width: 100%;
    table-layout: auto;
  }
  
  /* 바디 테이블의 헤더 숨김 */
  .scrollable-table-wrapper thead {
    visibility: hidden;
    height: 0;
  }
  
  /* 텍스트 오버플로우 처리 */
  .scrollable-table-container-single td,
  .scrollable-table-container-single th {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    position: relative;
  }
  
  /* 셀 내부의 모든 요소도 ellipsis 적용 */
  .scrollable-table-container-single td > *,
  .scrollable-table-container-single th > * {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: block;
    max-width: 100%;
  }
  
  /* flex 컨테이너는 예외 (버튼 그룹 등) */
  .scrollable-table-container-single td > .flex,
  .scrollable-table-container-single th > .flex {
    display: flex;
  }
  
  /* code, span 등 인라인 요소도 ellipsis */
  .scrollable-table-container-single td code,
  .scrollable-table-container-single td span:not(.flex *),
  .scrollable-table-container-single th code,
  .scrollable-table-container-single th span:not(.flex *) {
    display: inline-block;
    max-width: 100%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    vertical-align: bottom;
  }
  
  /* 스크롤바 스타일링 */
  .scrollable-table-wrapper::-webkit-scrollbar {
    width: 10px;
    height: 10px;  /* 가로 스크롤바 높이 */
  }
  
  .scrollable-table-wrapper::-webkit-scrollbar-track {
    background: hsl(var(--muted) / 0.3);
  }
  
  .scrollable-table-wrapper::-webkit-scrollbar-thumb {
    background: hsl(var(--muted-foreground) / 0.3);
    border-radius: 5px;
  }
  
  .scrollable-table-wrapper::-webkit-scrollbar-thumb:hover {
    background: hsl(var(--muted-foreground) / 0.5);
  }
  
  /* 컬럼 리사이즈 핸들 */
  .column-resizer {
    position: absolute;
    right: 0;
    top: 0;
    bottom: 0;
    width: 5px;
    cursor: col-resize;
    user-select: none;
    background: transparent;
    z-index: 1;
  }
  
  .column-resizer:hover {
    background: hsl(var(--primary) / 0.5);
  }
  
  .column-resizer.resizing {
    background: hsl(var(--primary));
  }
  
  .resizable-header {
    position: relative;
  }
}
```

### 테이블 구현 규칙

1. **단일 테이블 + Sticky 헤더**: 하나의 테이블로 구성
   - 헤더는 `position: sticky`로 고정
   - 바디만 스크롤
   - 헤더와 데이터가 자동으로 동일한 컬럼 너비 사용

2. **컬럼 정렬**: 
   - `table-layout: auto` 사용 (자동 너비 조정)
   - 컬럼 너비 (`w-20`, `w-32` 등)는 초기 너비 힌트
   - 리사이즈 시 인라인 스타일로 너비 적용

3. **텍스트 오버플로우 처리**:
   - `text-overflow: ellipsis` 로 긴 텍스트 말줄임표 처리
   - 호버 시 네이티브 브라우저 툴팁 (title 속성) 표시
   - 컬럼 너비 조절 시 동적으로 표시 범위 변경
   - 셀 높이는 호버 시에도 변경되지 않음

4. **컬럼 리사이즈**:
   - 각 헤더 셀 오른쪽 끝에 리사이저 핸들 자동 생성
   - 드래그로 컬럼 너비 조절 가능
   - 헤더와 바디 셀 너비 동시 적용
   - 최소 너비: 50px

5. **페이징**:
   - 기본 페이지 크기: 20개
   - 선택 가능: 10, 20, 50, 100, 전체
   - URL 파라미터: `?page=2&pageSize=50`

6. **높이 계산**:
   - 페이지: `h-[calc(100vh-6rem)]`
   - 제목 간격: `mb-3`
   - 버튼 간격: `mb-2`
   - 페이징 간격: `mt-1 mb-1`

7. **Table 컴포넌트 수정**:
   - `src/components/ui/table.tsx`의 `overflow-auto` 래퍼 제거됨
   - 스크롤은 외부 컨테이너에서 처리

### 주의사항

- ⚠️ 단일 테이블 구조이므로 헤더와 데이터 컬럼 너비가 자동으로 일치
- ⚠️ 긴 텍스트는 자동으로 말줄임표 처리되며, 호버 시 전체 표시됨
- ⚠️ 각 컬럼 오른쪽 끝을 드래그하여 너비 조절 가능
- ⚠️ 헤더는 sticky로 고정, 스크롤 시에도 항상 보임

### ScrollableTable 컴포넌트

**위치**: `src/components/ui/scrollable-table.tsx`

**기능**:
- 헤더와 바디의 가로 스크롤 동기화
- 긴 텍스트 말줄임표 처리 (hover 시 전체 표시)
- 컬럼 크기 조절 (드래그 리사이즈)
  - 각 헤더 셀 오른쪽 끝에 리사이저 핸들 자동 생성
  - 드래그로 컬럼 너비 조절 가능
  - 헤더와 바디 모두 동기화

**사용법**:
```tsx
import { ScrollableTable } from '@/components/ui/scrollable-table'

<ScrollableTable>
  <Table>
    <TableHeader>
      <TableRow>
        <TableHead>컬럼1</TableHead>
        <TableHead className="w-32">컬럼2</TableHead>
        {/* ... */}
      </TableRow>
    </TableHeader>
    <TableBody>
      {/* 데이터 행 */}
    </TableBody>
  </Table>
</ScrollableTable>
```

**리사이즈 기능**:
- 헤더 셀 오른쪽 경계에 마우스를 올리면 리사이저 핸들 표시
- 드래그하여 컬럼 너비 조절
- 최소 너비: 50px
- 헤더와 바디 셀 너비 자동 동기화

## 반응형 디자인

### AdminLayout (사이드바)

**브레이크포인트**: 1024px (lg)

#### Desktop (≥ 1024px)
- 사이드바: 고정 (`relative`)
- 너비: 256px (열림) / 64px (접힘)
- 토글: X / Menu 아이콘

#### Mobile (< 1024px)
- 사이드바: 자동 숨김 (`fixed`, `-translate-x-full`)
- 너비: 256px (항상)
- 오버레이: 열렸을 때 반투명 배경
- 햄버거 메뉴: 화면 왼쪽 상단 플로팅 버튼
- 메뉴 클릭 시: 자동으로 사이드바 닫힘

**화면 크기 감지**:
```tsx
useEffect(() => {
  const checkScreenSize = () => {
    const mobile = window.innerWidth < 1024
    if (mobile) setSidebarOpen(false)
  }
  window.addEventListener('resize', checkScreenSize)
}, [])
```

**헤더 UI**:
- AdminLayout에 상단 헤더 바 추가 (h-16)
- 다크모드 토글 (Moon/Sun 아이콘)
- 프로필 메뉴 (User 아이콘 + 드롭다운)
- 로그아웃 기능 포함
- ⚠️ **페이지 타이틀 제거**: 최상단 헤더의 페이지 제목 제거됨 (각 페이지의 Card 헤더에 표시)

**페이지 높이 계산**:
- AdminLayout 최상단: `admin-layout-container` 클래스 + 동적 높이 계산
- JavaScript로 `window.innerHeight` 계산하여 적용
- 윈도우 리사이즈 시 자동으로 재계산
- html, body: `height: 100%` (globals.css)
- AdminLayout의 main content: `flex-1 flex flex-col overflow-hidden`

**여백 최소화**:
- 헤더 카드: `py-1 px-3` (최소 패딩)
- 카드 간격: `mb-1` (최소 여백)
- List 컴포넌트 상단: `mt-2.5` (10px, 카드 상단 여백)
- 필터 영역: `mb-0.5` (최소 여백)
- 페이징 상단: `mt-2.5 mb-0` (10px, 테이블과 페이징 간격)
- 페이지 하단: `pb-5` (20px)

**재사용 가능한 CSS 클래스** (`globals.css`):
```css
@layer components {
  /* Admin 레이아웃 최상단 컨테이너 */
  .admin-layout-container {
    display: flex;
    height: 100vh;             /* 화면 전체 높이 */
    overflow: hidden;
    background: hsl(var(--background));
  }
  
  /* Admin 리스트 페이지 공통 레이아웃 */
  .admin-page-container {
    display: flex;
    flex-direction: column;
    height: 100%;              /* 부모(main - Top Header)의 100% */
    padding-left: 1.5rem;      /* 24px */
    padding-right: 1.5rem;     /* 24px */
    padding-bottom: 1.25rem;   /* 20px */
  }
  
  .admin-list-wrapper {
    flex: 1;                   /* 남은 공간 모두 사용 */
    min-height: 0;             /* flex 자식의 높이 제한 */
    display: flex;
    flex-direction: column;
    margin-top: 0.625rem;      /* 10px */
  }
  
  .admin-header-wrapper {
    flex-shrink: 0;
    margin-bottom: 0.25rem;    /* 4px */
  }
  
  .admin-header-card-content {
    display: flex;
    align-items: center;
    gap: 0.5rem;               /* 8px */
    padding-top: 0.25rem;      /* 4px */
    padding-bottom: 0.25rem;   /* 4px */
    padding-left: 0.75rem;     /* 12px */
    padding-right: 0.75rem;    /* 12px */
  }
  
  .admin-filter-wrapper {
    flex-shrink: 0;
    margin-bottom: 0.125rem;   /* 2px (카드 외부 사용 시) */
    display: flex;
    gap: 0.5rem;               /* 8px */
    align-items: center;
    /* 카드 내부 사용 시: mt-2로 타이틀 행과 간격 조정 */
  }
  
  .admin-table-spacing {
    flex-shrink: 0;
    margin-top: 0.625rem;      /* 10px */
    margin-bottom: 0;
  }
}
```

**사용 예시**:
- 페이지: `<div className="admin-page-container">`
- List wrapper: `<div className="admin-list-wrapper">`
- 헤더 wrapper: `<div className="admin-header-wrapper">`
- 헤더 카드 내용 (단일 행): `<CardContent className="admin-header-card-content">`
- 헤더 카드 내용 (필터 포함): `<CardContent className="admin-header-card-content flex-col items-start">`
- 필터 wrapper (카드 외부): `<div className="admin-filter-wrapper">`
- 필터 wrapper (카드 내부): `<div className="flex gap-2 items-center w-full mt-2">`
- 페이징: `<div className="admin-table-spacing">`

## EAV 패턴 및 데이터 관리 전략

### 개요

**Type/Attribute는 스키마 정의용, BusinessObject.data(JSON)는 실제 데이터 저장용**

### 아키텍처

#### 1. 메타데이터 계층 (스키마 정의)
- **Type**: 비즈니스 객체 타입 정의 (예: Invoice, Contract)
- **Attribute**: 공통 속성 정의 (예: invoiceNumber, customerName)
- **TypeAttribute**: Type과 Attribute의 연결 (Many-to-Many)

#### 2. 데이터 계층 (실제 인스턴스)
- **BusinessObject**: 비즈니스 객체 인스턴스
  - `typeId`: 어떤 Type인지 참조 (스키마 정의)
  - `data`: 실제 속성 값을 JSON으로 저장 (PostgreSQL JSONB)
  - ❌ **BusinessAttribute 테이블 제거됨** (EAV 방식 대신 JSON 사용)

### JSON 방식의 장점

| 항목 | EAV (BusinessAttribute) | JSON (data 필드) |
|------|-------------------------|------------------|
| 구조 | 복잡 (JOIN 필요) | ✅ 간단 (1행) |
| 성능 | 느림 (N개 행) | ✅ 빠름 |
| 쿼리 | 어려움 | ✅ JSONB 함수 활용 |
| 스키마 검증 | Type/Attribute | ✅ 동일하게 지원 |

### 사용 예시

```typescript
// 1. Type/Attribute 정의 (스키마)
const invoiceType = await prisma.type.create({
  data: { name: 'Invoice', description: '송장 문서 타입' },
})

const attr = await prisma.attribute.create({
  data: {
    key: 'invoiceNumber',
    label: '송장 번호',
    description: '고유 송장 식별 번호',
    attrType: 'STRING',
    isRequired: true,
  },
})

await prisma.typeAttribute.create({
  data: { typeId: invoiceType.id, attributeId: attr.id },
})

// 2. BusinessObject 생성 (data 필드에 JSON)
const invoice = await prisma.businessObject.create({
  data: {
    typeId: invoiceType.id,
    policyId: 'policy1',
    currentState: 'Draft',
    description: '2024년 11월 송장',
    data: {
      invoiceNumber: 'INV-2024-001',
      customerName: 'ABC 주식회사',
      totalAmount: 5000000,
      isPaid: false,
    },
  },
})

// 3. 조회 및 검증
const obj = await prisma.businessObject.findUnique({
  where: { id: invoice.id },
  include: {
    type: {
      include: {
        typeAttributes: {
          include: { attribute: true },
        },
      },
    },
  },
})

// 스키마 정의 확인
obj.type.typeAttributes.forEach((ta) => {
  console.log(`${ta.attribute.label}: ${ta.attribute.attrType}`)
})

// 실제 데이터 사용
const data = obj.data as Record<string, any>
console.log(data.invoiceNumber)  // 'INV-2024-001'
```

### PostgreSQL JSONB 쿼리 예시

```sql
-- 특정 속성 값으로 검색
SELECT * FROM "BusinessObject" 
WHERE data->>'invoiceNumber' = 'INV-2024-001';

-- 숫자 범위 검색
SELECT * FROM "BusinessObject" 
WHERE (data->>'totalAmount')::int > 1000000;

-- JSONB 인덱스 생성 (성능 최적화)
CREATE INDEX idx_business_object_data ON "BusinessObject" USING GIN (data);
```

---

## BusinessObject 리비전 자동 할당 시스템

### 개요

BusinessObject의 리비전을 Policy 기반으로 자동 할당하는 시스템입니다.

**핵심 개념:**
- **Policy**: `revisionSequence` 필드로 리비전 순서 정의 (예: "A,B,C")
- **Type**: 계층 구조 지원, 속성 상속 (`prefix`, `name`)
- **BusinessObject**: `typeId + policyId + name + revision` 조합으로 자동 관리

### 데이터 모델

#### Policy

```prisma
model Policy {
  id               String   @id @default(cuid())
  name             String
  version          Int      @default(1)
  revisionSequence String   @default("A,B,C")  // 리비전 순서
  
  types    Type[]
  businessObjects  BusinessObject[]
}
```

#### Type

```prisma
model Type {
  id       String   @id @default(cuid())
  type     String   @unique           // 고유 타입 (예: "invoice")
  name     String?                    // 사용자 친화적 이름 (상속 가능)
  prefix   String?                    // 접두사 (예: "INV", 상속 가능)
  
  policyId String
  policy   Policy   @relation(fields: [policyId], references: [id])
  
  // 계층 구조
  parentId String?
  parent   Type? @relation("TypeHierarchy", fields: [parentId], references: [id])
  children Type[] @relation("TypeHierarchy")
  
  objects  BusinessObject[] @relation("TypeObjects")
}
```

#### BusinessObject

```prisma
model BusinessObject {
  id             String   @id @default(cuid())
  typeId String?
  name           String?           // "송장-2025-001"
  revision       String?           // "A", "B", "C"
  policyId       String
  
  type Type? @relation("TypeObjects", fields: [typeId], references: [id])
  policy       Policy        @relation(fields: [policyId], references: [id])
  
  @@unique([typeId, name, revision])           // 이름 + 리비전 유니크
}
```

### 자동 할당 로직

**Prisma Middleware** (`src/lib/prisma/middleware.ts`):

1. **policyId 자동 할당**: Type의 policyId 사용
2. **name 자동 생성**: `prefix-timestamp-random` (예: `INV-20251102-042`)
3. **revision 순환**: Policy의 `revisionSequence`에 따라 A → B → C → A...

```typescript
// 사용 예시
const obj = await prisma.businessObject.create({
  data: {
    typeId: 'type1',
    name: '송장-001',  // 또는 생략 시 자동 생성
    currentState: 'draft',
  },
})
// 자동 할당: { policyId: 'p1', revision: 'A' }
```

### 속성 상속

**유틸리티 함수** (`src/lib/business-type-utils.ts`):

```typescript
import { getInheritedTypeAttributes } from '@/lib/business-type-utils'

const attrs = await getInheritedTypeAttributes(typeId)
// 결과: { prefix: 'INV', name: '일반 송장' }
// prefix/name이 없으면 부모로부터 재귀적으로 상속
```

### 계층 구조

```
Type (type: "document", prefix: "DOC")
└── Type (type: "invoice", prefix: "INV")
    └── Type (type: "tax-invoice", prefix: null)  // 부모로부터 "INV" 상속
```

### 마이그레이션

**파일**: `prisma/migrations/add_business_type_revision.sql`

```bash
# Supabase SQL Editor에서 실행
psql $DATABASE_URL -f prisma/migrations/add_business_type_revision.sql

# Prisma Client 재생성
npx prisma generate
```

### 주의사항

1. **유니크 제약**: 동일 `typeId + name + revision` 조합은 중복 생성 불가 (동일 name으로 여러 revision은 가능)
2. **revision 순환**: Policy의 `revisionSequence` 변경 시 기존 데이터 검증 필요
3. **속성 상속**: `prefix`, `name`이 없으면 부모 Type에서 조회

### 성능 최적화

```prisma
@@index([typeId, policyId, name, revision])  // 복합 인덱스
```

최신 revision 조회 시 빠른 성능 보장.

### 관련 문서

- `BUSINESS_OBJECT_REVISION.md`: 상세 설명 및 사용 예시
- `prisma/schema.prisma`: 전체 스키마 정의
- `src/lib/prisma/middleware.ts`: 자동 할당 로직
- `src/lib/business-type-utils.ts`: 유틸리티 함수

---

## 다크모드 및 테마

- **라이브러리**: next-themes
- **설정**: 
  - `<ThemeProvider attribute="class" defaultTheme="system" enableSystem>`
  - `suppressHydrationWarning` on `<html>` tag
- **토글**: AdminLayout 상단 헤더 (Moon/Sun 아이콘)
- **색상**: Tailwind CSS 변수 기반 (`hsl(var(--primary))`)

## Design Template 페이지

- **경로**: `/admin/design-template`
- **위치**: Help 메뉴 → Design Template 하위 메뉴
- **목적**: 모든 UI 컴포넌트 스타일 가이드
- **레이아웃**: `admin-page-container` + `admin-list-wrapper` 사용, 스크롤 가능
- **탭 구성**:
  1. **Buttons** - 모든 variants, sizes, states
  2. **Inputs** - Input (text, email, password, number, file), Textarea, Select, Checkbox, Radio Group, Date Picker, Calendar
  3. **Badges** - Badge variants, Alert variants
  4. **Tables** - BusinessObject 스타일 테이블 (ScrollableTable)
  5. **Menus** - DropdownMenu, Pagination
  6. **Dialogs** - Drawer, Color Palette, Typography
  7. **Advanced** - Accordion, Tooltip, Toggle, Toggle Group, Switch, Progress, Slider, Separator, Skeleton
- **주의사항**: Calendar/Toggle-Group 컴포넌트의 CSS 변수 구문 (`--spacing(var(--gap))`, `size-(--cell-size)`) 사용 금지, 표준 Tailwind 클래스 사용 (예: `gap-1`, `size-9`)

## 문서 구조

### user_scenario/ (사용자 시나리오 및 테스트)
- **USER_SCENARIO_TEST.md**: 7개 시나리오, 20개 단계, 42개 스크린샷
- **TEST_CHECKLIST.md**: 113개 테스트 항목
- **TEST_REPORT.md**: 자동화 테스트 결과 (100% 통과) ⭐
- **UI_COMPONENTS.md**: UI 컴포넌트 레퍼런스
- **screenshots/**: 테스트 스크린샷 폴더
- **업데이트**: 시나리오 수정 요청 시 문서 자동 업데이트

### docs/ (기술 문서)
- **database/DATABASE_MODEL_GUIDE.md**: 통합 데이터베이스 가이드 ⭐
- **api/**: API 가이드
- **testing/**: 테스트 가이드 (13개)
- **auth/**: 인증 가이드 (2개)
- **ui/**: UI/UX 가이드 (8개)
- **setup/**: 환경 설정 (4개)
- **archive/**: 아카이브 (4개)

## Policy 삭제 제약

- **onDelete**: `Restrict` (Cascade에서 변경)
- **종속 데이터 확인**:
  - State 존재 시 → 삭제 필요
  - Type 존재 시 → 삭제 또는 다른 Policy로 변경
  - BusinessObject 존재 시 → 삭제 또는 Type 변경
- **삭제 버튼**: 종속 데이터 있으면 비활성화

## 참고사항

- Supabase 콘솔에서 OAuth Redirect URLs 설정 필수
- 프로덕션 배포 시 `NEXT_PUBLIC_SITE_URL` 실제 도메인으로 변경
- RLS 정책 때문에 본인 데이터만 조회됨 (관리자 권한 필요 시 별도 정책 추가)
- Prisma 사용 시 `.env.local`에 `DATABASE_URL` 설정 필요

